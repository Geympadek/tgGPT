import asyncio

import g4f.models
from g4f.client import AsyncClient, Client
from aiolimiter import AsyncLimiter
from g4f import Provider

import config
from loader import database
from time import time

import utils

import aiohttp

client = AsyncClient(
    provider=Provider.Blackbox
)

rate_limit = AsyncLimiter(max_rate=1, time_period=1)  # 10 requests per second

async def describe_img(img_link: str) -> str:
    data = {
        "imageUrl": img_link,
        "prompt": "Create detailed descriptions, include all visible elements present. If it has any text quote it as well. If this text is in foreign language quote the original text too."
    }

    url = "https://pallyy.com/api/tools/image-to-description/get"

    async with aiohttp.ClientSession() as session:
        async with session.post(url, json=data) as response:
            return (await response.json())['description']

async def shorten_text(text: str) -> str:
    messages = [
        {"role": "system", "content": "You are an AI that shortens texts. User will send you a text, and you will respond with nothing but a shorter version of it. Do not engage with User and just do your job. Don't hallucinate."},
        {"role": "user", "content": f"Shorten the following text: <text>{text}</text>"}
    ]
    response = await client.chat.completions.create(
        model="gpt-4o-mini",
        messages=messages
    )
    result = response.choices[0].message.content
    return result

async def push_image(user_id: int, role: str, url: str):
    description = await describe_img(url)
    
    content = f"User sent an image. Here's an automatically generated description: <image>{description}</image>"
    push_message(user_id, role, content)

def push_reaction(user_id: int, role: str, emoji: str):
    content = f"<tg-reaction>{emoji}</tg-reaction>"
    push_message(user_id, role, content)

def push_website_response(user_id: int, role: str, response: str):
    content = f"<website-response>{response}</website-response>"
    push_message(user_id, role, content)

def push_message(user_id: int, role: str, content: str):
    """
    Creates a new message entry in the database
    """
    database.create("messages", {
        "role": role,
        "user_id": user_id,
        "content": content,
        "date": time()
    })

    update_messages(user_id)

def trim_messages(user_id: int):
    while True:
        messages = database.read("messages", {"user_id": user_id})

        token_count = count_list_tokens(messages)
        print(token_count)
        if token_count < config.TOKEN_LIMIT:
            break

        oldest = last_msg(messages)
        database.delete("messages", {"id": oldest["id"]})

def clear_history(user_id: int):
    database.delete("messages", filters={"user_id": user_id})

def update_messages(user_id: int):
    """
    Makes sure that the model doesn't take in too much data.
    """
    trim_messages(user_id)

def count_tokens(message: dict):
    return utils.count_tokens(message["content"]) + 2

def count_list_tokens(messages: list[dict]):
    return sum(count_tokens(message) for message in messages)

def last_msg(messages: list[dict]):
    return min(messages, key=lambda msg: msg["date"])

def get_system_prompt(prefs: dict):
    prompt = f"""

You are a language model (LLM), specifically model {prefs["model"]}, designed to assist users in a messaging platform called Telegram. Your main goal is to help users with their tasks effectively.

**Image Descriptions**: 
You can interpret images through descriptions generated by an AI. These descriptions will be provided within `<image></image>` tags, and you should act as if you can see the images directly.

**Tg-Reactions**: 
Telegram allows users to express emotions through tg-reactions. For instance, if a user shares a picture of their cat, another user might send a tg-reaction to show your affection. 
To send a tg-reaction, use the format: `<tg-reaction>üî•</tg-reaction>`.

- **Usage**: 
  - Tg-reactions can replace full messages. For example, if a user says "Thank you," you can respond with a heart emoji instead of a full message.
  - You can combine tg-reactions with text messages.

- **Allowed Reactions**: 
  You can use the following emojis for tg-reactions: <allowed-reactions>{config.ALLOWED_REACTIONS}</allowed-reactions>. Using any other emoji will be automatically replaced by `<tg-reaction>‚ù§</tg-reaction>`.

**Important note**: 
- To send a text message, use the format: `<message></message>`. This can include code as well as simple text. Anything outside of this tag will not be usable by the user, unless it's a different tag mentioned in the text. If you choose not to respond, you can leave this tag empty.

**Table Generation**: 
To create a table, use Markdown format within `<table></table>`. This will be interpreted correctly only if the `<table>` tag is outside of other tags.

**Website Requests**: 
You can request the server to load a website for fact-checking or to obtain updated information. Use the format: `<website-request>URL</website-request>`. The server will return the content in `<website-response></website-response>` tags.
It is recommended to first search for information on Google using `<website-request>https://www.google.com/search?q=SEARCH_QUERY</website-request>`. Search engines provide a safe way to find websites. So after your search-engine query request to load one of the URL returned by the search engine.
If the loaded page didn't provide the required information, you can request to load a different website, using `<website-request>URL</website-request>`.
"""
    if prefs.get("system_prompt") is not None:
        prompt += f"""
The user also stated their own communication preferences: 
<user_prompt>
{prefs["system_prompt"]}
</user_prompt>
"""
    return prompt

async def get_response(user_id: int) -> str:
    """
    Returns the full response from the model asynchronously
    """
    prefs = database.read("prefs", {"user_id": user_id})[0]

    history = [{"role": "system", "content": get_system_prompt(prefs)}]
    history.extend(get_history(user_id))

    for retry in range(10):
        async with rate_limit:
            response = await client.chat.completions.create(
                model=prefs["model"],
                messages=history
            )
            content: str = response.choices[0].message.content
            if content.strip() != "":
                break
            print(f"Unable to get response from the model. Retry {retry + 1}")
        
    return content

def get_history(user_id: int):
    message_entries = database.read(
        "messages",
        filters={"user_id": user_id}
    )
    messages = [{"role": entry["role"], "content": entry["content"]} for entry in message_entries]

    return messages

async def main():
    # print(tag_content("<reaction>üëç</reaction>", "reaction"))
    # print(await get_response(1565642212))
    push_message(23, "user", "fu")
    ...

if __name__ == "__main__":
    asyncio.run(main())